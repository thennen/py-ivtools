'''
This file should be run using the %run -i magic in ipython.
Provides a command based user interface for IV measurements.
make sure %matplotlib is in your ipython startup, or just make sure to run it first.
'''
import numpy
np = numpy
import matplotlib
mpl = matplotlib
from matplotlib import pyplot
plt = pyplot
import os
import sys
import time

# Rather than importing the modules and dealing with reload shenanigans that never actually work, use ipython run magic
%matplotlib
%run -i ivtools/measure.py
%run -i ivtools/plot.py
%run -i ivtools/io.py
%run -i ivtools/analyze.py

COUPLINGS = {'A': 'DC', 'B': 'DC', 'C': 'DC', 'D': 'DC'}
ATTENUATION = {'A': 1.0, 'B': 1, 'C': 1, 'D': 1.0}
OFFSET = {'A': 0.0, 'B': 0.0, 'C': 0.0, 'D': 0.0}
RANGE = {'A': 2.0, 'B': 2.0, 'C': 1.0, 'D': 1.0}

##### Make some plot windows, put them in places
try:
    # Close the figs if they already exist
    plt.close(fig1)
    plt.close(fig2)
except:
    pass
(fig1, ax1) , (fig2, ax2) = interactive_figures()

def clear_plots():
    # Clear IV loop plots
    ax1.cla()
    ax2.cla()
    ax1.set_title('IV Measurements')
    ax1.set_xlabel('Voltage')
    ax1.set_ylabel('Current')
    ax2.set_title('Picoscope Traces')
    ax2.set_xlabel('Data point')
    ax2.set_ylabel('Voltage [V]')

clear_plots()
#####

# Try to connect the instruments
# TODO: ps opens every time.  is this a problem?  how can we reuse the last connection?
# TODO: don't override channel settings
connect_instruments()

# Your data gets stored in this variable
data = np.array([], dtype=object)
# Your metadata gets stored in this variable
meta = dotdict()
plt.show()

def iv(vmin, vmax, duration=None, rate=None, n=1, fs=1e7, smartrange=False):
    '''
    Pulse a triangle waveform, plot pico channels, IV, and save to data variable
    '''
    global data

    # Channels that need to be sampled for measurement
    # channels = ['A', 'B', 'C']
    channels = ['A', 'B']

    # Need to know duration of pulse if only sweeprate is given
    # so that we know how long to capture
    sweeprate, pulsedur = _rate_duration(vmin, vmax, rate, duration)

    if smartrange:
        # Auto offset for current input
        print('Smart ranging is on.  Changing CHB offset')
        global OFFSET
        OFFSET['B'] = -COMPLIANCE_CURRENT * 2e3
        # Can do some other cool tricks here

    # Set picoscope to capture
    pico_capture(ch=channels,
                 freq=fs,
                 duration=n*pulsedur)
    # Send a triangle pulse
    tripulse(n=n,
             vmax=vmax,
             vmin=vmin,
             duration=duration,
             rate=rate)
    # Get the picoscope data
    chdata = get_data(channels)
    # Convert to IV data
    ivdata = pico_to_iv(chdata)
    # Append that data to global
    #data = np.append(data, ivdata) -- Doesn't work because of stupid data structure
    # For now just overwrite data..
    data = ivdata

    # Plot the IV data
    plotiv(ivdata, ax=ax1)

    # Remove previous lines
    for l in ax2.lines[::-1]: l.remove()
    # Plot the channel data
    plot_channels(chdata, ax=ax2)

    #plt.draw()
    plt.pause(.1)
